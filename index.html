function getV422Prediction(hist) {
        if(hist.length < 15) return [1,2,3,4,5,6,7,8];
        let stats = Array(40).fill(0).map((_, i) => ({ n: i, score: 0 }));
        const lastRow = hist[hist.length-1].nums;

        for(let i=1; i<=39; i++) {
            let gap = 0;
            for(let k=hist.length-1; k>=0; k--) {
                if(!hist[k].nums.includes(i)) gap++; else break;
            }
            // 策略：極大化短期熱號 (遺漏 0-2 期) 的分數，直接壓制冷號
            if (gap === 0) stats[i].score += 40; // 連莊權重拉高
            else if (gap <= 2) stats[i].score += 50; // 剛開過的回補權重最高
            else if (gap <= 5) stats[i].score += 20; 
            else stats[i].score -= 10; // 長冷號直接扣分，不讓它佔名額
        }

        // 尾數：縮短到最近 7 期，反映最即時的尾數熱度
        let tailMap = Array(10).fill(0);
        hist.slice(-7).forEach(d => d.nums.forEach(n => tailMap[n%10]++));
        for(let i=1; i<=39; i++) stats[i].score += (tailMap[i%10] * 8.0);

        // 鄰號：維持高權重 45，這是 539 命中 2-3 碼的關鍵
        lastRow.forEach(ln => {
            if(ln > 1) stats[ln-1].score += 45;
            if(ln < 39) stats[ln+1].score += 45;
        });

        // 區域過濾：確保 8 碼不會擠在同一個區間
        let zones = [[],[],[]];
        for(let i=1; i<=39; i++) {
            let z = Math.min(Math.floor((i-1)/13), 2);
            zones[z].push(stats[i]);
        }
        let pool = [];
        // 每區強迫取前 2-3 名，剩餘由總分決定
        zones.forEach(z => pool.push(...z.sort((a,b)=>b.score-a.score).slice(0, 2)));
        let finalPool = stats.sort((a,b)=>b.score-a.score).slice(0, 15); // 先取總分前 15
        
        return finalPool.filter(x => x.n > 0).slice(0, 8).map(x=>x.n).sort((a,b)=>a-b);
    }
