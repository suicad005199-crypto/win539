<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èº²é¿è€é—†å¤§ä½œæˆ°</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; }
        canvas { background: #87CEEB; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: crosshair; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// è¨­å®šç›´å¼æ¯”ä¾‹
canvas.width = 360;
canvas.height = 640;

const player = { x: canvas.width / 2 - 15, y: canvas.height - 50, w: 30, h: 30, speed: 8, isFiring: false };
const enemies = [];
const enemyTypes = [
    { name: 'è€é—†', color: 'red', msg: 'è¢«æŠ“å»åŠ ç­äº†ï¼ğŸ˜µ' },
    { name: 'åŒäº‹', color: 'orange', msg: 'è¢«æ‹‰å»é–‹æœƒäº†ï¼Boring~' },
    { name: 'çé‡‘', color: 'gold', msg: 'æ‹¿åˆ°çé‡‘ï¼Œæº–æ™‚ä¸‹ç­ï¼ğŸš€' }
];

// ç”Ÿæˆæ•µäºº
function spawnEnemy() {
    const side = Math.random() > 0.5 ? 'left' : 'right';
    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    enemies.push({
        x: side === 'left' ? -40 : canvas.width + 40,
        y: Math.random() * (canvas.height - 150) + 50,
        w: 40, h: 40,
        speed: (Math.random() * 3 + 2) * (side === 'left' ? 1 : -1),
        ...type
    });
}

setInterval(spawnEnemy, 800);

function update() {
    // ç©å®¶å°„æ“Šé‚è¼¯
    if (player.isFiring) {
        player.y -= player.speed;
        if (player.y < -30) resetPlayer();
    }

    // æ•µäººç§»å‹•èˆ‡ç¢°æ’
    enemies.forEach((en, index) => {
        en.x += en.speed;

        // ç¢°æ’æª¢æŸ¥
        if (player.isFiring && 
            player.x < en.x + en.w && player.x + player.w > en.x &&
            player.y < en.y + en.h && player.y + player.h > en.y) {
            
            alert(en.msg);
            resetPlayer();
            enemies.splice(index, 1);
        }

        // ç§»é™¤å‡ºç•Œæ•µäºº
        if (en.x > canvas.width + 50 || en.x < -100) enemies.splice(index, 1);
    });
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç•«ç©å®¶
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillStyle = '#000';
    ctx.fillText("æˆ‘", player.x + 10, player.y + 20);

    // ç•«æ•µäºº
    enemies.forEach(en => {
        ctx.fillStyle = en.color;
        ctx.fillRect(en.x, en.y, en.w, en.h);
        ctx.fillStyle = '#fff';
        ctx.fillText(en.name, en.x + 5, en.y + 25);
    });
}

function resetPlayer() {
    player.y = canvas.height - 50;
    player.isFiring = false;
}

canvas.addEventListener('click', () => {
    if (!player.isFiring) player.isFiring = true;
});

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
