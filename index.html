<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>逃離生活 - Escape Life</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; margin: 0 auto; }
        /* 為了讓背景圖適應全屏，可能需要調整 canvas 大小或背景圖片的縮放方式 */
    </style>
</head>
<body>

<script>
const config = {
    type: Phaser.AUTO,
    width: 400, // 遊戲基礎寬度，會根據 viewport 縮放
    height: 700, // 遊戲基礎高度
    backgroundColor: '#87CEEB', // 預設背景色，將被圖片覆蓋
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

let player;
let enemies;
let cursors;
let score = 0;
let scoreText;
let isGameOver = false;
let enemyTypes = ['老闆', '老婆', '主管', '房貸', '車貸', 'KPI'];
let background; // 新增背景變數

function preload() {
    // 預載入背景圖片
    this.load.image('gameBg', 'https://i.ibb.co/L50HjT1/background.png'); // 將替換成 Nano Banana 生成的背景圖 URL
}

function create() {
    // 1. 背景圖 (置於最底層)
    // 調整背景圖的縮放和位置使其覆蓋整個遊戲畫面
    background = this.add.image(config.width / 2, config.height / 2, 'gameBg');
    background.setDisplaySize(config.width, config.height); // 讓背景圖適應遊戲寬高

    // 2. 玩家 (社畜) - 在背景圖之上
    player = this.add.rectangle(200, 600, 40, 60, 0xffcc00).setDepth(1); // 增加深度，確保在背景之上
    this.physics.add.existing(player);
    player.body.setCollideWorldBounds(true);

    this.add.text(180, 590, '社畜', { fontSize: '14px', fill: '#000' }).setDepth(1);

    // 3. 障礙物群組
    enemies = this.physics.add.group();

    // 4. 定時生成敵人
    this.time.addEvent({
        delay: 1000,
        callback: spawnEnemy,
        callbackScope: this,
        loop: true
    });

    // 5. 分數
    scoreText = this.add.text(16, 16, '逃離值: 0', { fontSize: '24px', fill: '#fff', backgroundColor: '#33333380', padding: { x: 8, y: 4 } }).setDepth(2); // 增加深度和背景，讓分數清晰

    // 6. 輸入控制
    cursors = this.input.keyboard.createCursorKeys();
    
    // iOS 觸控支持
    this.input.on('pointerdown', (pointer) => {
        if (isGameOver) { // 遊戲結束時點擊重開
            window.location.reload();
            return;
        }
        if (pointer.x < config.width / 2) { // 螢幕左半邊
            player.body.setVelocityX(-300);
        } else { // 螢幕右半邊
            player.body.setVelocityX(300);
        }
    });
    this.input.on('pointerup', () => player.body.setVelocityX(0));

    // 碰撞偵測
    this.physics.add.overlap(player, enemies, hitEnemy, null, this);
}

function update() {
    if (isGameOver) return;

    // PC 鍵盤控制
    if (cursors.left.isDown) {
        player.body.setVelocityX(-300);
    } else if (cursors.right.isDown) {
        player.body.setVelocityX(300);
    } else if (this.input.pointer1.isDown === false) { // 確保滑鼠/觸控抬起時速度歸零
        player.body.setVelocityX(0);
    }

    // 更新分數
    score += 1;
    scoreText.setText('逃離值: ' + score);

    // 清除出界敵人
    enemies.children.iterate(enemy => {
        // enemy.body 可能是 null 如果已經被銷毀
        if (enemy && enemy.body && enemy.y > config.height + 50) {
            enemy.destroy(true); // 徹底銷毀
        }
    });
}

function spawnEnemy() {
    if (isGameOver) return;
    
    let x = Phaser.Math.Between(50, config.width - 50);
    let type = enemyTypes[Phaser.Math.Between(0, enemyTypes.length - 1)];
    
    let enemyBase = this.add.rectangle(x, -50, 80, 40, 0xff0000).setDepth(1);
    let enemyText = this.add.text(x - 25, -60, type, { fontSize: '18px', fill: '#fff' }).setDepth(1);
    
    this.physics.add.existing(enemyBase);
    this.physics.add.existing(enemyText);

    enemyBase.body.setVelocityY(250 + (score / 100)); // 隨時間變快
    enemyText.body.setVelocityY(250 + (score / 100));

    // 將文字和矩形綁定，讓它們一起移動
    enemyText.owner = enemyBase; // 方便管理
    enemies.add(enemyBase);
    enemies.add(enemyText); // 將文字也加入群組，方便統一管理

    // 敵人移動出界時，同時銷毀文字
    enemyBase.on('destroy', () => {
        if (enemyText && enemyText.active) enemyText.destroy();
    });
}

function hitEnemy(player, enemy) {
    if (isGameOver) return; // 避免重複觸發

    this.physics.pause();
    isGameOver = true;
    player.setAlpha(0.5); // 玩家半透明
    this.add.text(config.width / 2, config.height / 2 - 30, '被現實追上了...', { fontSize: '40px', fill: '#ff0000', backgroundColor: '#00000080', padding: { x: 10, y: 5 } }).setOrigin(0.5).setDepth(2);
    this.add.text(config.width / 2, config.height / 2 + 30, '點擊畫面重開', { fontSize: '20px', fill: '#fff', backgroundColor: '#00000080', padding: { x: 8, y: 4 } }).setOrigin(0.5).setDepth(2);
    
    // 遊戲結束時，只監聽一次觸控事件
    this.input.once('pointerdown', () => window.location.reload());
}
</script>

</body>
</html>
