<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>逃離生活 - Escape Life</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>

<script>
const config = {
    type: Phaser.AUTO,
    width: 400,
    height: 700,
    backgroundColor: '#87CEEB',
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

let player;
let enemies;
let cursors;
let score = 0;
let scoreText;
let isGameOver = false;
let enemyTypes = ['老闆', '老婆', '主管', '房貸', '車貸', 'KPI'];

function preload() {
    // 這裡可以預載入圖片，目前使用幾何圖形代替
}

function create() {
    // 1. 地板與背景
    this.add.rectangle(200, 350, 400, 700, 0x555555); // 模擬道路

    // 2. 玩家 (社畜)
    player = this.add.rectangle(200, 600, 40, 60, 0xffcc00);
    this.physics.add.existing(player);
    player.body.setCollideWorldBounds(true);

    this.add.text(180, 590, '社畜', { fontSize: '14px', fill: '#000' });

    // 3. 障礙物群組
    enemies = this.physics.add.group();

    // 4. 定時生成敵人
    this.time.addEvent({
        delay: 1000,
        callback: spawnEnemy,
        callbackScope: this,
        loop: true
    });

    // 5. 分數
    scoreText = this.add.text(16, 16, '逃離值: 0', { fontSize: '24px', fill: '#fff' });

    // 6. 輸入控制
    cursors = this.input.keyboard.createCursorKeys();
    
    // iOS 觸控支持
    this.input.on('pointerdown', (pointer) => {
        if (pointer.x < 200) {
            player.body.setVelocityX(-300);
        } else {
            player.body.setVelocityX(300);
        }
    });
    this.input.on('pointerup', () => player.body.setVelocityX(0));

    // 碰撞偵測
    this.physics.add.overlap(player, enemies, hitEnemy, null, this);
}

function update() {
    if (isGameOver) return;

    // PC 鍵盤控制
    if (cursors.left.isDown) {
        player.body.setVelocityX(-300);
    } else if (cursors.right.isDown) {
        player.body.setVelocityX(300);
    } else if (this.input.pointer1.isDown === false) {
        player.body.setVelocityX(0);
    }

    // 更新分數
    score += 1;
    scoreText.setText('逃離值: ' + score);

    // 清除出界敵人
    enemies.children.iterate(enemy => {
        if (enemy && enemy.y > 750) enemy.destroy();
    });
}

function spawnEnemy() {
    if (isGameOver) return;
    
    let x = Phaser.Math.Between(50, 350);
    let type = enemyTypes[Phaser.Math.Between(0, enemyTypes.length - 1)];
    
    let enemyBase = this.add.rectangle(x, -50, 80, 40, 0xff0000);
    let enemyText = this.add.text(x - 25, -60, type, { fontSize: '18px', fill: '#fff' });
    
    enemies.add(enemyBase);
    enemyBase.body.setVelocityY(250 + (score / 100)); // 隨時間變快
    
    // 讓文字跟著方塊動 (簡化版直接給文字速度)
    this.physics.add.existing(enemyText);
    enemyText.body.setVelocityY(250 + (score / 100));
}

function hitEnemy(player, enemy) {
    this.physics.pause();
    isGameOver = true;
    player.setAlpha(0.5);
    this.add.text(100, 300, '被現實追上了...', { fontSize: '40px', fill: '#ff0000' });
    this.add.text(130, 360, '點擊畫面重開', { fontSize: '20px', fill: '#fff' });
    
    this.input.on('pointerdown', () => window.location.reload());
}
</script>

</body>
</html>
